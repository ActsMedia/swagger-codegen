// Extensions.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
// Copyright Â© 2017 ActsMedia. All rights reserved.

import Foundation
import CoreData

extension NSEntityDescription {
	static func insertTypedNewObject<T: NSManagedObject>(into context: NSManagedObjectContext) -> T? {
		return NSEntityDescription.insertNewObject(forEntityName: String(describing: T.self), into: context) as? T
	}
}

extension NSManagedObject {
	static func getOrCreate(for uuid: String, in context: NSManagedObjectContext, with deletedOnServer: Bool) -> Self? {
		return getOrCreateGenericItem(for: uuid, in: context, with: deletedOnServer)
	}

	private static func getOrCreateGenericItem<T: NSManagedObject>(for uuid: String, in context: NSManagedObjectContext, with deletedOnServer: Bool) -> T? {
		if let existing: T = T.classedObject(for: uuid, in: context) {
			return existing
		} else if deletedOnServer {
			return nil
		}
		else {
			return NSEntityDescription.insertTypedNewObject(into: context)
		}
	}
}

private let dateFormatter: DateFormatter = {
	return DateFormatter(with: "yyyy-MM-dd")
}()

private let testDateFormatter: DateFormatter = {
	var aTestDateFormatter = DateFormatter(with: dateFormatter.dateFormat)
	aTestDateFormatter.timeZone = TimeZone(secondsFromGMT: 0)
	return aTestDateFormatter
}()

func delay<T>(with item: T, delayAmount: Double = 0, closure: @escaping (T) -> () ) {
	delay(amount: delayAmount) { closure(item) }
}

func delay<T>(with item: T?, delayAmount: Double = 0, closure: @escaping (T?) -> () ) {
	delay(amount: delayAmount) { closure(item) }
}

// From  http://stackoverflow.com/questions/24034544/dispatch-after-gcd-in-swift/24318861#24318861
func delay(amount: Double = 0, closure: @escaping () -> () ) {
	DispatchQueue.main.asyncAfter(deadline: DispatchTime(uptimeNanoseconds: 0), execute: closure)
}

func doInBackground(closure: @escaping () -> Void) {
	DispatchQueue.global().async(execute: closure)
}

extension DateFormatter {
	convenience init(with dateFormat: String) {
		self.init()
		self.dateFormat = "yyyy-MM-dd"
	}
}

extension Encodable {

	func encodeToJSON() throws -> Data {
		let data = try JSONEncoder().encode(self)
		return data
	}
	func encodeToJSON() throws -> String  {
		guard let data = try? JSONEncoder().encode(self), let json = String(data: data, encoding: .utf8) else {
			throw EncodingError.dataEncodingError(self)
		}
		return json
	}
}

extension Decodable {
	private static func decodeGenericJSON<T: Decodable>(from json: String) throws -> T {
		guard let data = json.data(using: .utf8) else {
			throw EncodingError.dataEncodingError(json)
		}
		let newInstance = try JSONDecoder().decode(T.self, from: data)
		return newInstance
	}

	private static func decodeGenericJSON<T: Decodable>(from jsonData: Data) throws -> T {
		let newInstance = try JSONDecoder().decode(T.self, from: jsonData)
		return newInstance
	}
    
	static func decodeJSON(from json: String) throws -> Self {
		return try decodeGenericJSON(from: json)
	}

	static func decodeJSON(from jsonData: Data) throws -> Self {
		return try decodeGenericJSON(from: jsonData)
	}
}

enum EncodingError: Error {
	case dataEncodingError(Any)
}
