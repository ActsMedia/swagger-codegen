// NetworkCall.swift
// Generated by Swagger
// https://github.com/swagger-api/swagger-codegen
//
// Changes by Paul Fechner Jr. 03/20/17
// Copyright Â© 2017 ActsMedia. All rights reserved.

import UIKit

protocol NetworkRequest {

	var headers: [String:String]? { get }
	var parameters: Encodable? { get }
	var method: String { get }
	var url: URL { get }
	var requiresResponse: Bool { get }
	var failure: (Error) -> () { get }

	//This should handle the result and decode it into the propper type
	func handleResult(result: Any?)
}

protocol ModelNetworkRequest: NetworkRequest {

	associatedtype ReturnType: Decodable
	var success: (ReturnType?) -> () { get }
}

extension ModelNetworkRequest {

	var method: String {
		return "POST"
	}

	var requiresResponse: Bool {
		return true
	}

	func handleResult(result: Any?) {
		guard let result = result, let resultJSON = result as? String else {
			delay(with: NetworkError.missingData, closure: failure)
			return
		}
        
        do {
            let returnItem = try ReturnType.decodeJSON(from: resultJSON)
            delay(with: returnItem, closure: success )
        } catch let error {
            print(error.localizedDescription)
            delay(with: NetworkError.invalidType(result), closure: failure)
            return
        }
		
		
	}
}

struct BackgroundNetworkCall<Body: Encodable, Return: Decodable> {

	var headers: [String : String]?

	var parameters: Encodable?

	var url: URL
    
    func asURLRequest() -> URLRequest? {
        
        let cachePolicy: URLRequest.CachePolicy = .reloadIgnoringLocalCacheData
        var request : URLRequest = URLRequest(url: url, cachePolicy: cachePolicy, timeoutInterval: 600)
        request.httpMethod = "POST"
        if let headers = headers, headers.count > 0 { 
            request.allHTTPHeaderFields = headers 
            
        }
        
        if let parameters = self.parameters {//where parameters.count > 0 {
            do {
                let bodyData: Data? = try parameters.encodeToJSON()
                request.httpBody = bodyData
            } catch {
                assertionFailure("Could not create data out of parameters \(parameters)")
                return nil
            }
        }
        return request as URLRequest
    }
}

struct NetworkCall<Body: Encodable, Return: Decodable>: ModelNetworkRequest {

	var parameters: Encodable? {
		return makeFullBody()
	}

	let body: Body
	let passedHeaders: [String : String]
	let useOauth: Bool
	let success: (Return?) -> ()
	let failure: (Error) -> ()
	let buildAsArray: Bool

	var url: URL

	var headers: [String : String]? {
		return makeFullHeaders()
	}

	init(body: Body, url: URL, passedHeaders: [String : String], useOauth: Bool, buildAsArray: Bool, success: @escaping (Return?) -> (), failure: @escaping (Error) -> ()) {
		self.body = body
		self.url = url
		self.passedHeaders = passedHeaders
		self.useOauth = useOauth
		self.success = success
		self.failure = failure
		self.buildAsArray = buildAsArray
	}

	init?(body: Body, urlPath: String, passedHeaders: [String : String], useOauth: Bool, buildAsArray: Bool, success: @escaping (Return?) -> (), failure: @escaping (Error) -> ()) {
		let url = Network.url(for: urlPath)
		self.init(body: body, url: url, passedHeaders: passedHeaders, useOauth: useOauth, buildAsArray: buildAsArray, success: success, failure: failure)
	}

	func makeFullHeaders() -> [String : String]? {
		var mutableHeaders = passedHeaders
		if useOauth {
			guard let authHeaders = Network.Header.standardIncludeAuth else {
				assertionFailure("Could not create an auth header")
				return nil
			}
			mutableHeaders.unionInPlace(with: authHeaders)
		}
		return mutableHeaders
	}

	func makeFullBody() -> Encodable {

		var parameters: Encodable = body

		if !buildAsArray, let arrayParams = body as? [Encodable], arrayParams.count == 1 {
			parameters = arrayParams[0]
		}
		return parameters
	}
}

class GenericAPI {

	class func genericArrayCall<Body: Encodable, Return: Decodable>( requiresOauth: Bool = true, headers: [String:String] = [:], path: String, body: Body, success: @escaping (Return?) -> (), failure: @escaping (Error) -> ()) {
		genericCall(requiresOauth: requiresOauth, sendAsArray: true, headers: headers, path: path, body: body, success: success, failure: failure)
	}

	class func genericArrayCall<Body: Encodable, Return: Decodable>( requiresOauth: Bool = true, headers: [String:String] = [:], url: URL, body: Body, success: @escaping (Return?) -> (), failure: @escaping (Error) -> ()) {
		genericCall(requiresOauth: requiresOauth, sendAsArray: true, headers: headers, url: url, body: body, success: success, failure: failure)
	}

	class func genericCall<Body: Encodable, Return: Decodable>(requiresOauth: Bool = true, sendAsArray: Bool = false, headers: [String:String] = [:], path: String, body: Body, success: @escaping (Return?) -> (), failure: @escaping (Error) -> ()) {
		genericCall(requiresOauth: requiresOauth, sendAsArray: sendAsArray, headers: headers, url: Network.url(for: path), body: body, success: success, failure: failure)
	}

	class func genericCall<Body: Encodable, Return: Decodable>(requiresOauth: Bool = true, sendAsArray: Bool = false, headers: [String:String] = [:], url: URL, body: Body, success: @escaping (Return?) -> (), failure: @escaping (Error) -> ()) {

		let call = NetworkCall<Body, Return>(body: body, url: url, passedHeaders: headers, useOauth: requiresOauth, buildAsArray: sendAsArray, success: success, failure: failure)
		_ = Network.Requestor.init(request: call).send()
	}
}

extension HTTPURLResponse {
    var isValid: Bool {
        return (self.statusCode > 199 && self.statusCode < 400) ? true : false
    }
}

let NotificationNameTokenRefresh = Notification.Name("TokenRefreshed")

extension Dictionary {
	mutating func unionInPlace(with dictionary: [Key : Value])  {
		for (key, value) in dictionary {
			self[key] = value
		}
	}

	// Thanks Airspeed Velocity
	mutating func unionInPlace<S: Sequence>(with sequence: S) where
		S.Iterator.Element == (Key,Value) {
		for (key, value) in sequence {
			self[key] = value
		}
	}
}


