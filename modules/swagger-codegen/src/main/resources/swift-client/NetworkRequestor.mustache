
//  NetworkRequestor.swift
// Generated by Swagger
// https://github.com/swagger-api/swagger-codegen
//
// Changes by Paul Fechner Jr. 03/20/17
// Copyright Â© 2017 ActsMedia. All rights reserved.

import Foundation

enum NetworkError: Error {
    case invalidCode(Int, Any?)
    case missingData
    case missingJSON(String?)
    case nonHTTPResponse
	case notConnected
	case invalidType(Any?)
}

extension URLRequest {
	init?(networkRequest: NetworkRequest) {
		let cachePolicy: URLRequest.CachePolicy = .reloadIgnoringLocalCacheData
		self.init(url: networkRequest.url, cachePolicy: cachePolicy, timeoutInterval: 120)
		httpMethod = networkRequest.method
		if (networkRequest.headers?.count ?? 0) > 0 {
			allHTTPHeaderFields = networkRequest.headers
		}
		if let params = networkRequest.parameters {
			httpBody = try? params.encodeToJSON()
		}

	}
}

protocol NetworkRequestor {

	init(request networkRequest: NetworkRequest)
	func send() -> Bool

	static func handleResponse(data: Data?, error: Error?, requiresResponse: Bool, success: (Any?) -> (), failure: (Error) -> ());
}

class SwaggerNetworkRequestor: NetworkRequestor {

	var networkRequest: NetworkRequest

	required init(request networkRequest: NetworkRequest) {
		self.networkRequest = networkRequest
	}

	/// All calls return on the the main queue
	func send() -> Bool {

		guard Reachability.isConnectedToNetwork() else {
			delay(with: NetworkError.notConnected, closure: networkRequest.failure)
			return false
		}

		guard let request = URLRequest(networkRequest: networkRequest) else {
			delay(with: NetworkError.missingData, closure: networkRequest.failure)
			return false
		}
		let configuration = URLSessionConfiguration.default
		configuration.urlCache = URLCache.shared
		let session = URLSession(configuration: configuration)
		session.dataTask(with: request, completionHandler: handleResponse) .resume()

		return true
	}

	private func handleResponse(data: Data?, response: URLResponse?, error: Error?) {

		SwaggerNetworkRequestor.handleResponse(data: data, response: response, error: error, requiresResponse: networkRequest.requiresResponse, success: { (result) in
			delay(with: result, closure: networkRequest.handleResult)
		}) { (error) in
			delay(with: error, closure: networkRequest.failure)
		}
	}

	static func handleResponse(data: Data?, response: URLResponse?, error: Error?, requiresResponse: Bool, success: (Any?) -> (), failure: (Error) -> ()) {

		// all these called methods should handle the error conditions, so if this fails we can just return.
		guard handleResponseError(error: error, failure: failure),
			let httpResponse = handleHTTPResponse(response: response, failure: failure),
			validate(response: httpResponse, data: data, failure: failure),
			let json = parseOrHandle(data: data, requiresResponse: requiresResponse, success: success, failure: failure) else {
				return
		}
		success(json)
	}

	static func handleResponse(data: Data?, error: Error?, requiresResponse: Bool, success: (Any?) -> (), failure: (Error) -> ()) {

		// all these called methods should handle the error conditions, so if this fails we can just return.
		guard handleResponseError(error: error, failure: failure),
			let json = parseOrHandle(data: data, requiresResponse: requiresResponse, success: success, failure: failure) else {
				return
		}
		success(json)
	}

	private static func handleResponseError(error: Error?, failure: (Error) -> ()) -> Bool {
		if let error = error{
			assertionFailure("We got an error \(error)")
			failure(error)
			return false
		}
		return true
	}

	private static func handleHTTPResponse(response: URLResponse?, failure: (Error) -> ()) -> HTTPURLResponse? {
		guard let httpResponse = response as? HTTPURLResponse else {
			assertionFailure("We were expecting an http response, but instead got: \(String(describing: response))")
			failure(NetworkError.nonHTTPResponse)
			return nil
		}

		return httpResponse
	}

	/// - Returns: if false, the calling process should halt.
	private static func validate(response httpResponse: HTTPURLResponse, data: Data?, failure: (Error) -> ()) -> Bool {

		guard httpResponse.isValid else {
			print("We got an invalid response code \(httpResponse.statusCode)")
			//                assertionFailure("We got an invalid response code \(httpResponse.statusCode)")
			let errorInfo: Any?
			if let data = data, let dataText = String(data: data, encoding: .utf8) {
                if let errorType = try? Swagger_error.decodeJSON(from: dataText) {
                    errorInfo = errorType
                }
                else {
                    errorInfo = dataText;
                }
			} else {
				errorInfo = nil
			}
			let httpError = NetworkError.invalidCode(httpResponse.statusCode, errorInfo)
			failure(httpError)
			return false
		}
		return true
	}

	/// - Returns: data deserialized into JSON, or nil if calling process should be halted. (Other behavior handled internally).
	private static func parseOrHandle(data: Data?, requiresResponse: Bool, success: (Any?) -> (), failure: (Error) -> ()) -> Any? {

		if !requiresResponse {
			success(nil)
			return nil
		}

		guard let data = data else {
			failure(NetworkError.missingData)
			return nil
		}
        let string = String(data: data, encoding: String.Encoding.utf8)
        return string
	}
}
