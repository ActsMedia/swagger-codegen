// CoreDataCommonalities.swift
// API Version {{appVersion}}
//

import Foundation
import CoreData

// MARK - Conform to Protocols From Swagger
{{#models}}{{#model}}{{#isBuildCoreData}}extension {{classname}}CD: Findable{{#isProtocolUUIDType}}, UUIDType{{/isProtocolUUIDType}}{{#isProtocolSortOrderType}}, SortOrderType{{/isProtocolSortOrderType}}{{#isProtocolNameType}}, NameType{{/isProtocolNameType}}{{#isProtocolSoftDeletableType}}, SoftDeletableType{{/isProtocolSoftDeletableType}} {}
{{/isBuildCoreData}}{{/model}}{{/models}}

// Findable Protocol - All Core Data Items are Findable
protocol Findable: class { }

extension Findable {
    static var allObjects: [Self] {
        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: String(describing: self))
        do {
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
}

// SortOrderType Protocol - If the object has a sort_order
protocol SortOrderType: Findable {
    var sort_order: Int? { get set } // always setting integers to max in Core Data
}

extension SortOrderType {
    static func sortedObjects(ascending: Bool) -> [Self] {
        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: String(describing: self))
        do {
            let sortDesc = NSSortDescriptor(key: "sort_order", ascending: ascending)
            fetch.sortDescriptors = [sortDesc]
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
}

// MARK: - Find items by UUID

@objc protocol UUIDType: class {
     var uuid: String! { get set }
     static func object(for uuid: String, in context: NSManagedObjectContext) -> NSManagedObject?
     static func objects(for uuids: [String], in context: NSManagedObjectContext) -> [NSManagedObject]?
     static var entityName: String { get }
}

extension NSManagedObject {
    @objc static var entityName: String { return String(describing: self) }
    
    @objc static func object(for uuid: String, in context: NSManagedObjectContext) -> NSManagedObject? {
        let predUuid = NSPredicate(format: "uuid = %@", uuid)
        let request = NSFetchRequest<NSFetchRequestResult>(entityName:entityName)
        request.predicate = predUuid;
        
        do {
            let results = try context.fetch(request)
            assert(results.count <= 1, "Never should have more than one uuid!")
            if let object = results.first as? NSManagedObject {
                return object
            }
        } catch (let error) {
            assertionFailure("\(error)")
        }
        return nil
    }
    
    @objc static func objects(for uuids: [String], in context: NSManagedObjectContext) -> [NSManagedObject]? {
		let objects = uuids.map{ object(for: $0, in: context) }.flatMap{ $0 }
        if objects.count > 0 {
            return objects
        } else {
            return nil
        }
    }
	
	static func classedObject<T: NSManagedObject>(for uuid: String, in context: NSManagedObjectContext) -> T? {
		return object(for: uuid, in: context) as? T
	}

    static func classedObjects<T: NSManagedObject>(for uuids: [String]?, in context: NSManagedObjectContext) -> Set<T>? {
		guard let uuids = uuids else {
			return nil
		}
		let predUuid = NSPredicate(format: "uuid IN %@", uuids)
		let request = NSFetchRequest<T>(entityName:entityName)
		request.predicate = predUuid;

		do {
			let results = try context.fetch(request)
			return Set(results)
		} catch (let error) {
			assertionFailure("\(error)")
		}
		return nil
	}
}

// MARK: - Search by String in Object Name

@objc protocol NameType: class {
    var name: String? { get set }
}

extension NameType {
    
    static func objects(withNameContaining aString: String) -> [Self] {

        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: String(describing: self))
        fetch.predicate = NSPredicate(format: "name CONTAINS[cd] %@", aString)
        fetch.sortDescriptors = [NSSortDescriptor(key: "name", ascending: true)]
        do {
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
    
    static func sortedByName(with ascending: Bool) -> [Self] {

        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: String(describing: self))
        do {
            let sortDesc = NSSortDescriptor(key: "name", ascending: ascending)
            fetch.sortDescriptors = [sortDesc]
            let results = try CDStack.context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
}

// MARK: - Find soft deleted items.

protocol SoftDeletableType {
    var deleted_on_server: Bool? { get set }
}

extension SoftDeletableType where Self: Any
{
    static func softDeletedObjects(_ context: NSManagedObjectContext) -> [Self] {

        let fetch = NSFetchRequest<NSFetchRequestResult>(entityName: String(describing: self))
        do {
            fetch.predicate = NSPredicate(format: "deleted_on_server == %@", NSNumber(value: true as Bool))
            let results = try context.fetch(fetch)
            return results as! [Self]
        } catch (let error) {
            assertionFailure("\(error)")
            return []
        }
    }
}